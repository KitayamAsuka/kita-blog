---
title: "你应该学会——世界上最好的分布式版本控制工具Git"
date: 2023-01-01T15:14:07+08:00
draft: false 
description: 工欲善其事
tags: 
    - Git
    - 实验
    - 工具
categories: 
    - 编程
---

Commit规范

1. 用空行将正文与主体分开
基本上就是总分的意思，有很多内容要提交的时候先主要的说一下这是在干嘛，然后空一行下面解释为什么要改动和改动的地方

2. 限制到50个字符以内
并不是强制要求，主要还是督促上传者精炼语句，提取关键信息，不过最多72个字符，因为在这之上commit会开始加...省略后面的内容

3. 每句话首字母大写
好看

4. 不要用句号给句子收尾
commit作为一个空间很紧张的地方不要用这种方式浪费

5. 使用强硬句式
Git中的反馈信息都是使用这种命令句式的，比起普通的叙述句式更让人能一看看出修改的内容。用`Refactor subsystem X for readability`取代`Fixed bug with Y`，更不要在commit里面写意义不明的`More fixes for broken stuff`，这种跟没写是一样的，根本起不到参考作用。
如果不习惯的话就想想加上If applied,this commit will *do sth*.后面的部分就是你应该写的commit。

6. 主体部分使用少于72字符
主要是会超出右边界

7. 用主体部分来解释什么和为什么，而不解释怎么样
解释怎么样就太长太长了，这个应该是你写到技术博客里的东西，在commit里可读性太差了。一般来说代码自身的改变就解释了怎么变化的，如果特别复杂那也是应该在源码注释里面说明

命令行的Git比IDE里的Git更强大，多用命令行。

---

Pro Git电子书笔记
只挑干的记

初始化仓库 `git init`

克隆仓库 `git clone <url> (option file name)`

检查文件状态 `git status`    加-s可以获得short版本的输出，??表示新文件，A代表暂存区文件，M代表修改过的文件，如果是MM是暂存后又修改了

跟踪文件 `git add <files>`    这里需要注意每做一次更改都需要add一次，不然commit上去的就是你最后一次add的，而不是你的最新文件

忽略文件 `.gitignore` 不需要更新的文件，比方说日志和编译文件
-   所有空行或者以 `#` 开头的行都会被 Git 忽略。
    
-   可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。
    
-   匹配模式可以以（`/`）开头防止递归。
    
-   匹配模式可以以（`/`）结尾指定目录。
    
-   要忽略指定模式以外的文件或目录，可以在模式前加上叹号（`!`）取反。
glob模式是一种简化的正则表达式
所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（`*`）匹配零个或多个任意字符；`[abc]` 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（`?`）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 `[0-9]` 表示匹配所有 0 到 9 的数字）。 使用两个星号（`**`）表示匹配任意中间目录，比如 `a/**/z` 可以匹配 `a/z` 、 `a/b/z` 或 `a/b/c/z` 等

查看已暂存和未暂存的修改 `git diff`   和status差不多，但是这个能看到文件内部的更改。`git diff --staged`可以查看已暂存文件和最后一次提交文件的差异。其本身只显示尚未add的改动

提交更新`git commit`  使用-m后缀增加注释内容，跳过暂存可以使用-a后缀，可以直接提交所有跟踪的文件

移除文件 `git rm`  从暂存区移除某个文件，移除后就不会再跟踪这个文件了，需要注意如果之前已经修改该或暂存过需要使用-f后缀强制删除。如果只想不跟踪而不在工作文件夹中删除这个文件使用`--cached`，或者去.gitignore文件里面忽略。rm命令也可以使用glob模式，例如`git rm log/\*.log`就是删除log文件夹下所有.log文件

移动文件`git mv file_from file_to` 实际上是执行了复制，删除源文件，add新文件三条命令。不过git明白这相当于是一次重命名

查看提交历史 `git log` 使用-p后缀可以看到每次提交的差异，也可以输入类似-2的后缀来限制输出最新的两次提交。--stat显示统计信息。--pretty\==oneline 会显示把提交放在一行展示，另有short，full和fuller选项和format选项。--graph会给你的命令行带一点符号来展示图形，稍微形象一些。也可以用--since和--until来限制时间，比方说`git log --since=2.weeks` 或者使用--author和--grep这样来精细检索。还有一种过滤器-S，可以筛选出添加或删除了某个字符串的提交。e.g.`git log -S function_name`

撤销操作 `git commit --amend` 可以补上忘记添加的文件，如果没有，那也可以改提交信息，历史中也只会保存后来修改的提交

取消暂存的文件 `git reset <filename>` 让某个文件离开暂存区，这是个危险的命令，尤其是在加上--hard之后
当然了也可以用`git checkout -- <file>` ，Git会用最近提交的版本覆盖这个文件。需要注意的是在Git中可以被恢复的数据都是已提交的

查看远程仓库`git remote` 会列出远程服务器的简写，origin会是默认名字

添加远程仓库`git remote add <shortname> <url>`这样可以指定一个名字，这样以后可以用这个名字来代替链接

从远程仓库中抓取与拉取`git fetch <remote>`这个命令只会下载数据，不会合并代码，而`git pull`可以自动抓取后合并

推送到远程仓库`git push <remote> <branch>` 这个命令必须在之前没有人推送时才能起作用，也就是说更改过的版本你必须先fetch才能再push

查看某个远程仓库`git remote show <remote>` 

远程仓库的重命名与移除`git remote rename` 和`git remote remove` 

列出标签`git tag` 可以显示出版本号

创建标签
1. 附注标签 `git tag -a` 如果后面不加-m的话Git会要求你写入指定信息
2. 轻量标签 `git tag <version>` 后面不加别的，只有版本信息

后期打标签 在末尾指定提交的校验和

共享标签`git push origin <tagname>` push并不会默认上传标签，需要显式推送

删除标签 `git tag -d <tagname>` 如果要删除远程标签的话`git push origin --delete <tagname>` 

检出标签 `git checkout` 这个还挺麻烦的，如果需要做更改的话需要创建新分支

Git别名，在config文件里面设置自动推断比方说`git config --global alias.ci commmit` 可以用`git ci`替代`git commit` 
常用的有`git config --global alias.unstage 'reset HEAD --'`
`git config --global alias.last 'log -l HEAD'` 
该命令可以看最后一次提交
如果要写外部命令只要在命令前加！就可以替换了

分支创建`git branch <name>` 这里需要注意一点，Git的分支都是以指针移动到对应快照上，并非创建新的副本

分支切换`git checkout <branch>` 

删除分支`git branch -d <name>`

冲突处理，在针对同一处位置的多个修改时不会触发fast-forwarding，也就是说Git不会帮你自动合并，需要你自己处理。在`<<<<`和`=====` 之间的是上半部分，和`>>>>>`之间的是下半部分，这两部分是发生冲突的地方，需要进行处理，最后别忘了把这些符号也都删掉。解决完成后再add和commit就可以了

分支管理`git branch` 会列出所有分支，`*`代表目前所在分支。后缀加-v可以看到各个分支最后一次提交，--merged可以看到已合并到当前分支的分支，--no-merged则是未合并的，对于没星号已合并的分支可以直接删除，未合并的会报错，要删的话用-D

pull和fetch的区别，pull会自动merge，而fetch不会，它只是单纯的下载本地没有的数据

删除远程分支`git push origin --delete <branch>` 会删除远程服务器上的这个分支指针，通常来说已删除的分支还会在服务器上保留一段时间，便于恢复

变基`rebase` 将提交某一分支的所有更改移至另一分支
![](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)
这样做的好处比起merge来说看起来更简洁（只有一条线，而不是变成树型，虽然某种意义上这个还是树型...）
反正就...看图吧，实在不会用乖乖merge无非难看点
![](https://git-scm.com/book/en/v2/images/interesting-rebase-3.png)
![](https://git-scm.com/book/en/v2/images/interesting-rebase-4.png)
![](https://git-scm.com/book/en/v2/images/interesting-rebase-5.png)
需要注意
>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。
>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。

想象一下就知道如果在多人开发中使用这种技巧很有可能导致别人开发的东西在一个已经被删除的分支上，而你们两个怎么也碰不到一起，因为你总要rebase。或者对方会在你的操作之间commit，天啊想想就是一场灾难

当然也有补救措施，但是考虑到这会给团队中的每个人带来大量的学习成本，而且我暂时也用不到，作为merge派我还是以后需要了再学吧



Git的四种协议，本地协议，HTTP协议，SSH协议，Git协议
- 本地协议 最常用的，如果文件前指定file://会使用网络传输的进程，会降低效率
优点是简单，如果设置过共享文件夹的话由于其分布式的特性会很方便。缺点是这个不一定快，比起那些有大量CDN服务器的网站来说。而且NFS访问一般也比SSH慢，而且每个成员都有完整的shell权限，如果被恶意破坏没有办法阻止

- HTTP协议 有智能HTTP和哑HTTP之分，不关注了。好处是用着简单，高效且快，如果HTTPS的话还安全。缺点是服务器上架设麻烦。

- SSH协议 这玩意不用介绍了吧。优点是简单、安全、高效。缺点是不支持匿名

- Git协议 有点像是可以匿名的SSH，不过不需要限权完全没有安全措施。有点是这个是最快的。缺点是缺乏授权机制。常用的方法是开放Git协议但是只读，SSH或HTTPS协议用来给开发者写入权限。而且这个架设难度很高，需要开放9418端口，企业一般不会允许开放非标准端口

生成SSH公钥。公钥一般存在于`~/.ssh`下，以id_dsa和id_rsa命名，带有.pub后缀的是公钥，另一个是私钥。如果没有就运行ssh-keygen命令生成。

后面是将怎么手动搭建自己的Git服务器的，我用不到，而且现在一般都用成熟的套件（GitLab）一步一步配置下来吧，有前端可以看。或者直接使用专业的托管网站比方说Github
